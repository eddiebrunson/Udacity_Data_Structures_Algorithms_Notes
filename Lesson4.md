# Lesson 4: Efficiency 

1. Efficiency

We said earlier that this Nanodegree program is about how to write code to **solve problems** and to do so **efficiently**.

Previously, we looked at some basic aspects of solving problems--but we didn't really think too much about whether our solutions were efficient. 

**Space and time**

When we refer to *efficiency* of a program, we aren't just thinking about its speed--we're considering both the **time** it will take to run the program *and* the amount of **space** the program will require in the computer's memory. Often there will be a trade-off between the two, where you can design a program that runs faster by slecting a data structure that takes up more space--or vice versa. 


--> Efficiency is perhaps the most important concept in this course. 

--> Efficiency a.k.a. complexity is how well you're using your computer's resources to get a particular job done. 

You can think of it as:

* How long does your code take to run? 
* How much storage space do you need?

** Algorithms**

An **algorithm** is essentially a *series of steps for solving a problem.* Usually, an algorithm takes some kind of input (such as an unsorted list) and then produces the desired output (such as a sorted list). 

For any given problem, there are usually many different algorithms that will get you to exactly the same end result. But some will be more efficient than others. To be an effective problem solver, you'll need to develop the ability too look at a problem and identify different algorithms that could be used--and then contrast those algorithms to consider which will be more or less efficient. 

**But Computers are so fast!**

Sometimes it seems like computers run programs so quickly that efficiency shouldn't really matter. And in some cases, this is true--one version of a program may take 10 times longer than another, but they both still run so quickly that it has no real impact. 

But in other  cases, a small difference in how your code is written--or a tiny change in the type of data structure you use--can mean the difference between a program that runs in a fraction of a millisecond and a program that takes hours (or even years!) to run. 


2. Quantifying Efficiency 


